# 📚 4주차 2번째 수업

## 01. 노드와 포인터 (개념 복습)

✔️ 5개의 원소를 가진 배열의 순서 리스트가 있을 때, 물리적 메모리 공간에 **연속적으로** write되는 특성이 있다.<br>
🤔 고려해야 할 사항 : 하나를 삭제하면? 더 넣으려면? 역순으로 표현하거나 임의의 순서대로 표현할 수 있는지?<br>
<br>
1. 삽입 : L=(cho,kim,lee)가 있을 때 han을 삽입해서 인덱스값이 달라짐. L=(cho,han,kim,lee)<br>
2. 삭제 : 위의 리스트에서 cho를 삭제하면 L=(han,kim,lee)가 되고 맨 뒤의 공간이 하나가 빈다.<br><br>

👍 장점: 표현이 간단하고 메모리 주소로 직접 변환이 가능해서 빠른 접근이 가능.<br>
👎 단점: 순차적으로만 표현이 가능해서, 자료 이동이 시간이 걸리거나 크기가 미리 정해져서 메모리 내 저장공간 전체가 할당되었다가 회수됨.<br><br>

❗️ **Linked list**<br>
연결 리스트는 원소의 물리적인 순서가 논리적인 순서와 일치할 필요가 없는 리스트이다. 대신 , 이 원소에 대한 주소도 같이 저장해야한다.<br>
노드 : < 원소, 주소 > 쌍의 구조이며, 데이터 필드와 링크 필드로 구성되어 있다.<br>

<img width="683" alt="스크린샷 2020-05-04 오후 9 29 05" src="https://user-images.githubusercontent.com/35520314/80965868-4a198080-8e4e-11ea-8bc7-3569b8e65576.png">
<br>
  📙특징<br>
  - 연결 리스트 내의 모든 엘리먼트는 '노드'라고 부른다.<br>
  - 각 노드는 다음 노드에 대한 메모리 주소, 즉 포인터를 갖고 있다.<br>
  📗 장점 <br>
  - 순서대로 한꺼번에 저장되는 것이 아니라, 임의의 위치에 저장되어 편리함.<br>
  - 노드 삽입, 삭제 비용이 감소한다.<br>
  📘 단점 <br>
  - 포인터 개념을 잘 활용해야해서 난이도가 있음.<br>
  - 다음 노드 주소를 저장할 링크를 추가해야해서 메모리가 소모됨.<br><br>

### 🔗 연결 리스트 (Linked List)

<img width="728" alt="스크린샷 2020-05-04 오후 9 36 15" src="https://user-images.githubusercontent.com/35520314/80966345-54884a00-8e4f-11ea-9bfb-a1f2c95943fe.png">
<br>
연결 리스트의 마지막 노드 링크 값은 위 그림에서도 볼 수 있듯이, null값으로 저장된다. 연결 리스트 전체는 pointer 변수 'L'로 나타내며, 첫 번째 노드 주소인
1000번지가 L에 저장된다.<br>

L.data = "Cho"(L이 가리키는 1000번지 주소의 데이터 값 Cho)<br>
L.link = "1008" 주소(다음 노드의 주소 값)<br>
L.link.data = "Kim" (다음 노드 주소 값의 데이터니까 Kim)<br>
<br>

 > p = null 또는 p!=null : 포인터 값이 null인지 아닌지 검사<br>
 > p = q : 포인터 p와 q가 같은 노드 주소를 가리키는지?<br>
 > p <- null : p 포인터 값으로 null 지정 <br>
 > p <- q : q가 가리키는 노드를 p도 가리키게끔 함.<br>
 > p.link <- q : p가 가리키는 노드 링크필드에 q의 포인터 값을 저장 <br>
 > p <- q.link : q가 가리키는 노드 링크필드 값을 p 포인터 값으로 지정 <br><br>
 

## 02. C언어에서의 포인터

👉 포인터(pointer) : 다른 어떤 변수의 주소 값을 저장하는 변수로, c언어에서는 모든 변수가 주소를 갖고 있어서 모든 타입에 대해 포인터 타입이 존재한다.<br>
❗️ 포인터 선언 : 데이터 타입이나 이름 뒤에 * 식별자를 붙인다.<br><br>

**포인터 초기화**<br>
```
char c ='k';
char *pc ; 
pc = &c; /* pc에는 char 타입 변수 주소인 &이 저장된다. */
```
<br>
**값 참조 및 변경**<br>

```
/* 초기화 이후 값을 참조하기 */
printf("c is %c \n",c);
printf("c is %c \n", *pc);

/* 값을 변경하는 법 */
pc = &c;
c = 'y';
*pc = 'y';
```

<br>

📌 포인터 개념 복습하기!<br>
<img width="728" alt="스크린샷 2020-05-04 오후 9 46 33" src="https://user-images.githubusercontent.com/35520314/80967071-b9906f80-8e50-11ea-8f69-cdb13224a2bb.png"><br>

<img width="728" alt="스크린샷 2020-05-04 오후 9 46 25" src="https://user-images.githubusercontent.com/35520314/80967058-b4cbbb80-8e50-11ea-93a9-a02e11b90b8c.png"><br>

🧞‍♂️ 포인터의 종류: void* int/float,char* / int** (포인터를 가리키는 포인터)/ struct test * ps (test 타입 구조체 가리키는 포인터) / void(* f)(int) 는 함수를 가리키는 f 포인터 <br>
👉 포인터는 형 변환이 가능하다.<br><br>

### 포인터 인자 

함수 안에 파라미터 값으로 전달된 a,b의 주소인 포인터를 이용해서 변경이 가능하다.<br>
<img width="728" alt="스크린샷 2020-05-04 오후 9 51 01" src="https://user-images.githubusercontent.com/35520314/80967440-59e69400-8e51-11ea-8860-b0cd173d5cc1.png"><br>

### 배열에 대한 포인터

배열의 이름은 사실상 포인터의 역할을 하며, 컴파일러가 배열 이름을 배열의 첫 번째 주소로 대치한다. A[10] 이 곧 포인터 주소같은.<br>
그래서 선언하려면 char letters[10], * pc; 와 같이 함께 선언해줄 수도 있다. 여기에는 또 포인터에 연선자도 사용할 수 있는데,
++ 연산자를 사용하면 현재 원소 다음의 원소를 가리키게 된다.<br><br>

### 포인터 배열

포인터 배열은 C에서는 어떠한 타입의 변수 배열도 정의가 가능하다. 포인터 또한 다른 변수의 주소를 저장하는 '주소'이기 떄문에, 배열로 만들 수 있다.<br>

<img width="728" alt="스크린샷 2020-05-04 오후 9 54 02" src="https://user-images.githubusercontent.com/35520314/80967717-c5c8fc80-8e51-11ea-89c3-d019d285e0c8.png"><br>

### 구조체 포인터

구조체의 요소에 포인터 변수로 접근하는 연산자.<br>
<img width="759" alt="스크린샷 2020-05-04 오후 9 55 32" src="https://user-images.githubusercontent.com/35520314/80967839-fb6de580-8e51-11ea-9e16-4bcc7acd0332.png"><br>

또한 자체참조 구조도 있는데, struct 멤버와 같은 type의 또 다른 struct를 지시하는 포인터도 될 수 있다. 이는 특히 리스트의 노드를 정의하는 데 유용하다.<br>
- typeof : 리스트 처리를 위해 노드와 포인터를 정의할 때 typeof로 간결하게 함.

```
typeof struct char_list_node *list_pointer;
struct char_list_node{
 char letter,
 list_pointer next;
};
list_pointer p = NULL;
```

### 포인터의 포인터

<img width="759" alt="스크린샷 2020-05-04 오후 10 06 13" src="https://user-images.githubusercontent.com/35520314/80968753-797ebc00-8e53-11ea-867a-f48f441005cf.png"><br>
🎖 사칙연산 : p가 있을 때, p+1, p-1로 앞 뒤 객체를 나타낼 수 있음.<br>
🤔 포인터 사용 시 주의점: 포인터가 아무것도 가리키고 있지 않으면 int * p = NULL; <-이렇게 null로 지정해주기! 초기화가 되어있지 않은 상태에서 쓰면 안된다.
<br>

### 동적 메모리 할당

프로그램이 메모리를 할당 받을 때는 정적과 동적이 있는데, 정적 메모리는 크기가 프로그램 수행하기 전 컴파일 단계에서 결정된다. 그래서 수행 도중에는 크기가 변경될 수
없으며, 이것보다 크게 들어오면 처리를 못하고 너무 적게 들어오면 메모리가 낭비된다. 이에 비해 동적 메모리 할당은 프로그램 실행 도중에 할당을 받기 때문에 필요한 만큼만
할당받고 반납할 수 있어 매우 효율적인 사용이 가능하다.<br><br>

1️⃣ malloc(int size) : size 바이트 만큼만 메모리 블록 할당 <br>
2️⃣ free (void ptr) : ptr이 가리키는 할당된 메모리 블록을 해제 <br>
3️⃣ size keyword : 변수나 타입 크기 반환(바이트 단위로)<br><br>


