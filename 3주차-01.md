# 📚 3주차 1번째 수업

## 📌 들어가기에 앞서
 > 프로그램은 '단계적 기획'이다. <br>
 > sw 생명 주기는 요구분석~구현부터 검사, 유지보수  <br>
 > 프로그램 성능은 O, 오메가, 세타로 알 수 있다. (점근적)  <br>
 
## 01. 배열 추상 데이터 타입

- 데이터의 표현: 고급 표현은 추상적,논리적 -> low 데이터는 연산자로 구현해야 실현 가능.  <br>
1. 순차 표현: 배열  <br>
2. 연결 표현: 연결 리스트  <br> <br>

❓ 배열이란 : 같은 형의 변수를 여러 개 만드는 경우. 하나로 묶었으면 좋겠다! 주어진 각 인덱스에 대해 하나의 값이 연관된 쌍들의 집합을 '배열'이라고 한다. <br>
<img width="722" alt="스크린샷 2020-05-04 오후 5 52 12" src="https://user-images.githubusercontent.com/35520314/80949972-fdbf4800-8e2f-11ea-8409-ee0a7f9d62f8.png">
루프를 돌면서 i부터 n까지 돌면서 큰 값을 temp에 넣는다. 만약 배열이 없었더라면 이렇게 루프 돌릴 수 없었을 것이다.

<br>
- 1차원 배열 : int A[6]; 순차적! <br>
- 2차원 배열 : int A[3][4]; 실제 메모리 안에서는 [0][0],[0][1]...이차적으로 표현 가능<br>
<img width="722" alt="스크린샷 2020-05-04 오후 5 56 03" src="https://user-images.githubusercontent.com/35520314/80950284-86d67f00-8e30-11ea-8eee-42bbecfc9954.png">
<br>
- 특성 : 순차적인 메모리 할당 방식, <index, value> 쌍의 집합, 원소들이 모두 같은 타입(int,4byte). 즉 같은 크기를 가짐 <br>
- index <-를 보고 값에 접근함. 순서를 나타내는 표현.

✅ index : 배열 내에서 원소의 상대적인 위치를 나타냄. 인덱스가 하나로 표현되면 1차원, n개로 표현되면 n차원 배열임. <br>
배열 A[] 의 인덱스는 원소 값의 쌍 <i,v>의 집합으로 정의한다. <br>

✅ ADT 정의: object -> a set of pairs <index, value > 이때, 인덱스 부분의 1차원일 경우, 0~n-1 로 나타냄.<br>
1차원은 {0,1,2....n-1}, 2차원은 {<(0,0),7>,(1,0),(1,1).....} 으로 표현한다.
<img width="722" alt="스크린샷 2020-05-04 오후 6 02 28" src="https://user-images.githubusercontent.com/35520314/80950749-6d820280-8e31-11ea-895b-42ed3e519c30.png">
<br>

❗️연산자 : create() , retrieve(), store()<br>
❗️배열 ADT의 장점: 배열에 포함되어야 하는 데이터와 연산들을 명확하게 정의, 배열의 본질을 정확하게 표현 <br>

<br>

## 02. 배열의 표현

1️⃣ 1차원 배열<br>

주소가 å가 0이라고 하면 a[0] 4, a[1] 8....이된다.
a는 배열 이름이고, n은 원소의 최대 수, 인덱스는 {0,1,2...} 순으로 간다.
<img width="363" alt="스크린샷 2020-05-04 오후 6 30 47" src="https://user-images.githubusercontent.com/35520314/80952878-61983f80-8e35-11ea-837c-ed49a6ef728c.png">

메모리를 표현하자면, 연속ㅈ거인 메모리 주소를 배열에 할당하고 배열의 논리적 순서와 메모리의 물리적 순서가 같도록 표현한다.

👉C에서는 : int list[5] -> int 정수를 5개 만큼 연속 정의함. <br>int * plist[5] -> 정수 변수 주소를 담고 있는 포인터의 변수 (int*)를 정의함.
<br>1차원 배열의 구현을 저렇게 했을 때, 각 변수의 시작 주소는 0,4,8,12,16...으로 간다.
<br>

2️⃣ 2차원 배열<br>

a[n1,n2] 으로, n1은 행의 수, n2는 열의 수이다. 원소는 a[i,j]로 표현한다. 2차원 배열은 1차원 메모리로 사상됨.(행 우선, 열 우선)<br>
a[3][2] 3개의 원소로 구성된 2개의 행
<img width="363" alt="스크린샷 2020-05-04 오후 6 35 22" src="https://user-images.githubusercontent.com/35520314/80953198-04e95480-8e36-11ea-960c-a808024619e8.png">

a[0,2]의 주소는 å + 0*3=2 = å*2, a[1,0]의 주소는 å+1*3+0 = å+3... 즉 a[n1,n2]의 주소가 å일 때, 원소 a[i,j]의 주소는 **å+i*n2+j** 가 된다.
<br><br>
3️⃣ 3차원 배열<br> 

3차원 배열은 a[n1,n2,n3]으로 면, 행, 열이 된다. n1개의 2차원 배열이 존재하는 것임.
<img width="868" alt="스크린샷 2020-05-04 오후 6 43 00" src="https://user-images.githubusercontent.com/35520314/80953741-167f2c00-8e37-11ea-8ee8-34f7cb3269f5.png">
a[0,n2,n3] a[1,n2,n3]....a[n-1,n2,n3]으로 표현한다. 3차원까지는 다뤘는데, 이 공식을 어떤 식으로 일반화 할지?<br>

👉 A[4][2][3] -> 2개 행 3개 열이 4개가 존재한다. j는 차원의 값을 따져서 3이고, i=1이면 4개의 엘리먼트/2면 2/3이면 3으로 체크한다. 
<br><br>

4️⃣ 다차원 배열<br>

a[upper0][upper1]....[upper n-1] -> 엘리먼트의 개수는 
